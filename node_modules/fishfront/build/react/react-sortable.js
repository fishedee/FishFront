'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var _nextSibling;

var _activeComponent;

var _defaultOptions = {
	ref: 'list',
	model: 'items',

	animation: 150,
	onStart: 'handleStart',
	onEnd: 'handleEnd',
	onAdd: 'handleAdd',
	onUpdate: 'handleUpdate',
	onRemove: 'handleRemove',
	onSort: 'handleSort',
	onFilter: 'handleFilter',
	onMove: 'handleMove'
};

function _getModelName(component) {
	return component.sortableOptions && component.sortableOptions.model || _defaultOptions.model;
}

function _getModelItems(component) {
	var name = _getModelName(component),
	    items = component.state && component.state[name] || component.props[name];

	return items.slice();
}

function _extend(dst, src) {
	for (var key in src) {
		if (src.hasOwnProperty(key)) {
			dst[key] = src[key];
		}
	}

	return dst;
}

/**
 * Simple and easy mixin-wrapper for rubaxa/Sortable library, in order to
 * make reorderable drag-and-drop lists on modern browsers and touch devices.
 *
 * @mixin
 */
var SortableMixin = {
	sortableMixinVersion: '0.1.0',

	/**
  * @type {Sortable}
  * @private
  */
	_sortableInstance: null,

	componentDidMount: function componentDidMount() {
		var _this = this;

		var options = _extend(_extend({}, _defaultOptions), this.sortableOptions || {}),
		    copyOptions = _extend({}, options),
		    emitEvent = (function ( /** string */type, /** Event */evt) {
			var method = this[options[type]];
			method && method.call(this, evt, this._sortableInstance);
		}).bind(this);

		// Bind callbacks so that "this" refers to the component
		'onStart onEnd onAdd onSort onUpdate onRemove onFilter onMove'.split(' ').forEach(function ( /** string */name) {
			copyOptions[name] = (function (evt) {
				if (name === 'onStart') {
					_nextSibling = evt.item.nextElementSibling;
					_activeComponent = this;
				} else if (name === 'onUpdate') {
					evt.from.insertBefore(evt.item, _nextSibling);

					var oldIndex = evt.oldIndex,
					    newIndex = evt.newIndex;

					this.changeSortable(oldIndex, newIndex);
				}

				setTimeout(function () {
					emitEvent(name, evt);
				}, 0);
			}).bind(this);
		}, this);
		require.ensure([], function () {
			var Sortable = require('../util/sortable');
			_this._sortableInstance = Sortable.create(_this.refs[options.ref], copyOptions);
		});
	},

	componentWillUnmount: function componentWillUnmount() {
		this._sortableInstance = null;
	}
};
exports.default = SortableMixin;